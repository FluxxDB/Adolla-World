-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local Object = TS.import(script, TS.getModule(script, "object-utils"))
local _services_0 = TS.import(script, TS.getModule(script, "services"))
local Players = _services_0.Players
local ReplicatedStorage = _services_0.ReplicatedStorage
local RunService = _services_0.RunService
local Networking = {}
do
	local _container_1 = Networking
	local Sink = {}
	_container_1.Sink = Sink
	local function populateEvents(names, map)
		for _, name in ipairs(names) do
			if RunService:IsClient() then
				local instance = ReplicatedStorage:WaitForChild(name)
				if instance:IsA("RemoteEvent") then
					local _2 = map
					local _3 = name
					local _4 = instance
					-- ▼ Map.set ▼
					_2[_3] = _4
					-- ▲ Map.set ▲
				end
			else
				local instance = ReplicatedStorage:FindFirstChild(name)
				if instance then
					if not instance:IsA("RemoteEvent") then
						error("Found " .. name .. " but it is not a remote.")
					end
					local _2 = map
					local _3 = name
					local _4 = instance
					-- ▼ Map.set ▼
					_2[_3] = _4
					-- ▲ Map.set ▲
				else
					local remote = Instance.new("RemoteEvent")
					remote.Name = name
					remote.Parent = ReplicatedStorage
					local _2 = map
					local _3 = name
					local _4 = remote
					-- ▼ Map.set ▼
					_2[_3] = _4
					-- ▲ Map.set ▲
				end
			end
		end
	end
	local function createEvent(_serverGuards, _clientGuards, serverMiddleware, clientMiddleware)
		local serverGuards = _serverGuards
		local clientGuards = _clientGuards
		local globalEvents = {}
		local remotes = {}
		populateEvents(Object.keys(serverGuards), remotes)
		populateEvents(Object.keys(clientGuards), remotes)
		local _result_2
		if RunService:IsServer() then
			_result_2 = serverMiddleware
		else
			_result_2 = clientMiddleware
		end
		local middleware = _result_2
		local connections = {}
		local eventExecutors = {}
		for name in pairs(remotes) do
			local executor = function(player, ...)
				local args = { ... }
				local _3 = connections
				local _4 = name
				local bindable = _3[_4]
				if not bindable then
					return warn("no bindable for", name)
				end
				return bindable:Fire(player, unpack(args))
			end
			local startingExecutor = executor
			local _3 = middleware
			if _3 ~= nil then
				_3 = _3[name]
			end
			local eventMiddleware = _3
			if eventMiddleware ~= nil then
				do
					local _4 = false
					local _i_5 = #eventMiddleware - 1
					local _6 = _i_5
					_i_5 = _6
					while true do
						local i = _i_5
						if _4 then
							i -= 1
						else
							_4 = true
						end
						if not (i >= 0) then
							break
						end
						local middleware = eventMiddleware[i + 1](startingExecutor, {
							name = name,
						})
						startingExecutor = middleware
						_i_5 = i
					end
				end
			end
			local _4 = eventExecutors
			local _5 = name
			local _6 = startingExecutor
			-- ▼ Map.set ▼
			_4[_5] = _6
			-- ▲ Map.set ▲
		end
		local function fireConnections(event, player, ...)
			local args = { ... }
			local _3 = eventExecutors
			local _4 = event
			local executor = _3[_4]
			if executor ~= nil then
				return executor(player, unpack(args))
			end
		end
		if RunService:IsServer() then
			globalEvents.server = {}
			globalEvents.server.connect = function(self, event, cb, additionalGuards)
				local _3 = remotes
				local _4 = event
				local remote = _3[_4]
				local guards = serverGuards[event]
				if not remote then
					error("Could not find remote " .. tostring(event))
				end
				if not guards then
					error("Could not find guards for " .. tostring(event))
				end
				local _5 = connections
				local _6 = event
				local bindable = _5[_6]
				if not bindable then
					local _7 = connections
					local _8 = event
					bindable = Instance.new("BindableEvent")
					local _9 = bindable
					-- ▼ Map.set ▼
					_7[_8] = _9
					-- ▲ Map.set ▲
				end
				return bindable.Event:Connect(function(player, ...)
					local args = { ... }
					if additionalGuards then
						do
							local _7 = false
							local _i_8 = 0
							local _9 = _i_8
							_i_8 = _9
							while true do
								local i = _i_8
								if _7 then
									i += 1
								else
									_7 = true
								end
								if not (i < #guards) then
									break
								end
								local guard = additionalGuards[i + 1]
								if guard ~= nil and not guard(args[i + 1]) then
									return nil
								end
								_i_8 = i
							end
						end
					end
					return cb(player, unpack(args))
				end)
			end
			for name in pairs(clientGuards) do
				local _3 = remotes
				local _4 = name
				local remote = _3[_4]
				local method = {
					fire = function(self, player, ...)
						local args = { ... }
						remote:FireClient(player, unpack(args))
					end,
					broadcast = function(self, ...)
						local args = { ... }
						remote:FireAllClients(unpack(args))
					end,
					except = function(self, players, ...)
						local args = { ... }
						local _5 = players
						if typeof(_5) == "Instance" then
							players = { players }
						end
						for _, player in ipairs(Players:GetPlayers()) do
							local _6 = players
							local _7 = player
							if not (table.find(_6, _7) ~= nil) then
								self:fire(player, unpack(args))
							end
						end
					end,
				}
				setmetatable(method, {
					__call = function(method, player, ...)
						local args = { ... }
						local _5 = player
						local _condition_6 = typeof(_5) == "Instance"
						if _condition_6 then
							_condition_6 = player:IsA("Player")
						end
						if _condition_6 then
							method:fire(player, unpack(args))
						end
					end,
				})
				globalEvents.server[name] = method
			end
			for name, remote in pairs(remotes) do
				remote.OnServerEvent:Connect(function(player, ...)
					local args = { ... }
					local guards = serverGuards[name]
					if not guards then
						error("Could not find guards for " .. name)
					end
					do
						local _3 = false
						local _i_4 = 0
						local _5 = _i_4
						_i_4 = _5
						while true do
							local i = _i_4
							if _3 then
								i += 1
							else
								_3 = true
							end
							if not (i < #guards) then
								break
							end
							local guard = guards[i + 1]
							if not guard(args[i + 1]) then
								return nil
							end
							_i_4 = i
						end
					end
					fireConnections(name, player, unpack(args))
				end)
			end
		else
			globalEvents.client = {}
			globalEvents.client.connect = function(self, event, cb, additionalGuards)
				local _3 = remotes
				local _4 = event
				local remote = _3[_4]
				local guards = clientGuards[event]
				if not remote then
					error("Could not find remote " .. tostring(event))
				end
				if not guards then
					error("Could not find guards for " .. tostring(event))
				end
				local _5 = connections
				local _6 = event
				local bindable = _5[_6]
				if not bindable then
					local _7 = connections
					local _8 = event
					bindable = Instance.new("BindableEvent")
					local _9 = bindable
					-- ▼ Map.set ▼
					_7[_8] = _9
					-- ▲ Map.set ▲
				end
				return bindable.Event:Connect(function(player, ...)
					local args = { ... }
					if additionalGuards then
						do
							local _7 = false
							local _i_8 = 0
							local _9 = _i_8
							_i_8 = _9
							while true do
								local i = _i_8
								if _7 then
									i += 1
								else
									_7 = true
								end
								if not (i < #guards) then
									break
								end
								local guard = additionalGuards[i + 1]
								if guard ~= nil and not guard(args[i + 1]) then
									return nil
								end
								_i_8 = i
							end
						end
					end
					return cb(unpack(args))
				end)
			end
			for name in pairs(serverGuards) do
				local _3 = remotes
				local _4 = name
				local remote = _3[_4]
				globalEvents.client[name] = (function(...)
					local args = { ... }
					remote:FireServer(unpack(args))
				end)
			end
			for name, remote in pairs(remotes) do
				remote.OnClientEvent:Connect(function(...)
					local args = { ... }
					local guards = clientGuards[name]
					if not guards then
						error("Could not find guards for " .. name)
					end
					do
						local _3 = false
						local _i_4 = 0
						local _5 = _i_4
						_i_4 = _5
						while true do
							local i = _i_4
							if _3 then
								i += 1
							else
								_3 = true
							end
							if not (i < #guards) then
								break
							end
							local guard = guards[i + 1]
							if not guard(args[i + 1]) then
								return nil
							end
							_i_4 = i
						end
					end
					fireConnections(name, nil, unpack(args))
				end)
			end
		end
		return globalEvents
	end
	_container_1.createEvent = createEvent
end
return {
	Networking = Networking,
}
