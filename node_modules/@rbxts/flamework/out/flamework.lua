-- Compiled with roblox-ts v1.1.1
local TS = _G[script]
local _services_0 = TS.import(script, TS.getModule(script, "services"))
local Players = _services_0.Players
local RunService = _services_0.RunService
local Flamework
local Flamework = {}
do
	local _container_1 = Flamework
	local flameworkConfig = {
		isDefault = true,
	}
	_container_1.flameworkConfig = flameworkConfig
	_container_1.isInitialized = false
	local metadata = {}
	_container_1.metadata = metadata
	local targetToId = {}
	_container_1.targetToId = targetToId
	local idToTarget = {}
	_container_1.idToTarget = idToTarget
	-- * @hidden
	local function registerMetadata(target, data)
		local ctor = target
		local _2 = metadata
		local _3 = ctor
		local _4 = data
		-- ▼ Map.set ▼
		_2[_3] = _4
		-- ▲ Map.set ▲
		local _5 = targetToId
		local _6 = ctor
		local _7 = data.identifier
		-- ▼ Map.set ▼
		_5[_6] = _7
		-- ▲ Map.set ▲
		local _8 = idToTarget
		local _9 = data.identifier
		local _10 = ctor
		-- ▼ Map.set ▼
		_8[_9] = _10
		-- ▲ Map.set ▲
	end
	_container_1.registerMetadata = registerMetadata
	local resolvedDependencies = {}
	local loadingList = {}
	-- * @hidden
	local id, resolveDependency
	local function createDependency(ctor)
		local _2 = loadingList
		local _3 = ctor
		if table.find(_2, _3) ~= nil then
			-- ▼ ReadonlyArray.join ▼
			local _4 = " <=> "
			if _4 == nil then
				_4 = ", "
			end
			local _5 = table.create(#loadingList)
			for _k_6, _v_7 in ipairs(loadingList) do
				_5[_k_6] = tostring(_v_7)
			end
			-- ▲ ReadonlyArray.join ▲
			error("Circular dependency detected " .. table.concat(_5, _4) .. " <=> " .. tostring(ctor))
		end
		local _4 = loadingList
		local _5 = ctor
		-- ▼ Array.push ▼
		_4[#_4 + 1] = _5
		-- ▲ Array.push ▲
		local _6 = metadata
		local _7 = ctor
		local dependencyMetadata = _6[_7]
		if not dependencyMetadata then
			error("Dependency " .. tostring(id) .. " metadata is missing.")
		end
		local constructorDependencies = {}
		if dependencyMetadata.dependencies then
			for index, dependencyId in pairs(dependencyMetadata.dependencies) do
				local dependency = resolveDependency(dependencyId)
				constructorDependencies[index - 1 + 1] = dependency
			end
		end
		local dependency = ctor.new(unpack(constructorDependencies))
		-- ▼ Array.pop ▼
		loadingList[#loadingList] = nil
		-- ▲ Array.pop ▲
		return dependency
	end
	_container_1.createDependency = createDependency
	-- * @hidden
	function resolveDependency(id)
		local _2 = resolvedDependencies
		local _3 = id
		local resolvedDependency = _2[_3]
		if resolvedDependency ~= nil then
			return resolvedDependency
		end
		local _4 = idToTarget
		local _5 = id
		local ctor = _4[_5]
		if ctor == nil then
			error("Dependency " .. id .. " could not be found.")
		end
		local dependency = createDependency(ctor)
		local _6 = resolvedDependencies
		local _7 = id
		local _8 = dependency
		-- ▼ Map.set ▼
		_6[_7] = _8
		-- ▲ Map.set ▲
		return dependency
	end
	_container_1.resolveDependency = resolveDependency
	-- * @hidden
	local function _addPaths(...)
		local args = { ... }
		local preloadPaths = {}
		for _, arg in ipairs(args) do
			local service = table.remove(arg, 1)
			local currentPath = game:GetService(service)
			if service == "StarterPlayer" then
				if arg[1] ~= "StarterPlayerScripts" then
					error("StarterPlayer only supports StarterPlayerScripts")
				end
				if not RunService:IsClient() then
					error("The server cannot load StarterPlayer content")
				end
				currentPath = Players.LocalPlayer:WaitForChild("PlayerScripts")
				table.remove(arg, 1)
			end
			do
				local _2 = false
				local _i_3 = 0
				local _4 = _i_3
				_i_3 = _4
				while true do
					local i = _i_3
					if _2 then
						i += 1
					else
						_2 = true
					end
					if not (i < #arg) then
						break
					end
					currentPath = currentPath:WaitForChild(arg[i + 1])
					_i_3 = i
				end
			end
			local _2 = preloadPaths
			local _3 = currentPath
			-- ▼ Array.push ▼
			_2[#_2 + 1] = _3
			-- ▲ Array.push ▲
		end
		local preload = function(moduleScript)
			local start = os.clock()
			local _2 = require
			local _3 = moduleScript
			local _success_4, _valueOrError_5 = pcall(_2, _3)
			local result = _success_4 and {
				success = true,
				value = _valueOrError_5,
			} or {
				success = false,
				error = _valueOrError_5,
			}
			local endTime = math.floor((os.clock() - start) * 1000)
			if not result.success then
				error(moduleScript:GetFullName() .. " failed to preload (" .. tostring(endTime) .. "ms): " .. result.error)
			end
			print("Preloaded " .. moduleScript:GetFullName() .. " (" .. tostring(endTime) .. "ms)")
		end
		for _, path in ipairs(preloadPaths) do
			if path:IsA("ModuleScript") then
				preload(path)
			end
			for _, instance in ipairs(path:GetDescendants()) do
				if instance:IsA("ModuleScript") then
					preload(instance)
				end
			end
		end
	end
	_container_1._addPaths = _addPaths
	-- * @hidden
	local function _implements(object, id)
		local objectMetadata
		while objectMetadata == nil and object ~= nil do
			local _2 = metadata
			local _3 = object
			objectMetadata = _2[_3]
			if objectMetadata then
				break
			end
			local mt = getmetatable(object)
			if mt then
				object = mt.__index
			else
				object = nil
			end
		end
		if not objectMetadata then
			return false
		end
		if not objectMetadata.implements then
			return false
		end
		local _2 = objectMetadata.implements
		local _3 = id
		return table.find(_2, _3) ~= nil
	end
	_container_1._implements = _implements
	local function getDecorator(ctor, configType)
		local _2 = metadata
		local _3 = ctor
		local objectMetadata = _2[_3]
		if not objectMetadata then
			return nil
		end
		for _, decorator in ipairs(objectMetadata.decorators) do
			if decorator.config.type == configType then
				return decorator
			end
		end
	end
	local function fastSpawn(func)
		local bindable = Instance.new("BindableEvent")
		bindable.Event:Connect(func)
		bindable:Fire()
		bindable:Destroy()
	end
	local externalClasses = {}
	--[[
		*
		* Allow an external module to be bootstrapped by Flamework.ignite()
	]]
	local function registerExternalClass(ctor)
		local _2 = externalClasses
		local _3 = ctor
		-- ▼ Set.add ▼
		_2[_3] = true
		-- ▲ Set.add ▲
	end
	_container_1.registerExternalClass = registerExternalClass
	local hasFlameworkIgnited = false
	--[[
		*
		* Initialize Flamework.
		*
		* This will start up the lifecycle events on all currently registered
		* classes.
		*
		* You should preload all necessary directories before calling this
		* as newly registered classes will not run their lifecycle events.
		*
		* @returns All the dependencies that have been loaded.
	]]
	local function ignite(patchedConfig)
		if hasFlameworkIgnited then
			error("Flamework.ignite() should only be called once")
		end
		hasFlameworkIgnited = true
		if patchedConfig then
			for key, value in pairs(patchedConfig) do
				flameworkConfig[key] = value
			end
		end
		for ctor, objectMetadata in pairs(metadata) do
			local _condition_2 = flameworkConfig.loadOverride
			if _condition_2 then
				local _3 = flameworkConfig.loadOverride
				local _4 = ctor
				_condition_2 = not (table.find(_3, _4) ~= nil)
			end
			if _condition_2 then
				if not objectMetadata.isPatched then
					continue
				end
			end
			resolveDependency(objectMetadata.identifier)
		end
		local dependencies = {}
		local decoratorType = RunService:IsServer() and "Service" or "Controller"
		for id in pairs(resolvedDependencies) do
			local _2 = idToTarget
			local _3 = id
			local ctor = _2[_3]
			if ctor == nil then
				error("Could not find constructor for " .. id)
			end
			local _4 = metadata
			local _5 = ctor
			local objectMetadata = _4[_5]
			if objectMetadata == nil then
				error("Could not find metadata for " .. id)
			end
			local decorator = getDecorator(ctor, decoratorType)
			if not decorator then
				continue
			end
			local _condition_6 = objectMetadata.isExternal
			if _condition_6 then
				local _7 = externalClasses
				local _8 = ctor
				_condition_6 = not (_7[_8] ~= nil)
			end
			if _condition_6 then
				continue
			end
			local dependency = resolveDependency(objectMetadata.identifier)
			local _7 = dependencies
			local _8 = { dependency, objectMetadata, decorator.config }
			-- ▼ Array.push ▼
			_7[#_7 + 1] = _8
			-- ▲ Array.push ▲
		end
		local start = {}
		local init = {}
		local tick = {}
		local render = {}
		local physics = {}
		local _2 = dependencies
		local _3 = function(_param_4, _param_5)
			local a = _param_4[3]
			local b = _param_5[3]
			local _condition_6 = a.loadOrder
			if _condition_6 == nil then
				_condition_6 = 1
			end
			local _condition_7 = b.loadOrder
			if _condition_7 == nil then
				_condition_7 = 1
			end
			return _condition_6 < _condition_7
		end
		-- ▼ Array.sort ▼
		table.sort(_2, _3)
		-- ▲ Array.sort ▲
		for _, _binding_6 in ipairs(dependencies) do
			local dependency = _binding_6[1]
			local objectMetadata = _binding_6[2]
			local config = _binding_6[3]
			if Flamework._implements(dependency, "$:Gp") then
				local _7 = init
				local _8 = { dependency, objectMetadata, config }
				-- ▼ Array.push ▼
				_7[#_7 + 1] = _8
				-- ▲ Array.push ▲
			end
			if Flamework._implements(dependency, "$:Op") then
				local _7 = start
				local _8 = { dependency, objectMetadata, config }
				-- ▼ Array.push ▼
				_7[#_7 + 1] = _8
				-- ▲ Array.push ▲
			end
			if Flamework._implements(dependency, "$:eA") then
				local _7 = tick
				local _8 = dependency
				-- ▼ Array.push ▼
				_7[#_7 + 1] = _8
				-- ▲ Array.push ▲
			end
			if Flamework._implements(dependency, "$:r5") then
				local _7 = physics
				local _8 = dependency
				-- ▼ Array.push ▼
				_7[#_7 + 1] = _8
				-- ▲ Array.push ▲
			end
			if Flamework._implements(dependency, "$:kJ") then
				local _7 = render
				local _8 = dependency
				-- ▼ Array.push ▼
				_7[#_7 + 1] = _8
				-- ▲ Array.push ▲
			end
		end
		for _, _binding_6 in ipairs(init) do
			local dependency = _binding_6[1]
			local initResult = dependency:onInit()
			if TS.Promise.is(initResult) then
				initResult:await()
			end
		end
		_container_1.isInitialized = true
		RunService.Heartbeat:Connect(function(dt)
			for _, dependency in ipairs(tick) do
				coroutine.wrap(function()
					return dependency:onTick(dt)
				end)()
			end
		end)
		RunService.Stepped:Connect(function(time, dt)
			for _, dependency in ipairs(physics) do
				coroutine.wrap(function()
					return dependency:onPhysics(dt, time)
				end)()
			end
		end)
		if RunService:IsClient() then
			RunService.RenderStepped:Connect(function(dt)
				for _, dependency in ipairs(render) do
					coroutine.wrap(function()
						return dependency:onRender(dt)
					end)()
				end
			end)
		end
		for _, _binding_6 in ipairs(start) do
			local dependency = _binding_6[1]
			fastSpawn(function()
				return dependency:onStart()
			end)
		end
		return dependencies
	end
	_container_1.ignite = ignite
	--[[
		*
		* Preload the specified paths by requiring all ModuleScript descendants.
	]]
	--[[
		*
		* Retrieve the identifier for the specified type.
	]]
	--[[
		*
		* Check if object implements the specified interface.
	]]
	--[[
		*
		* Creates a type guard from any arbitrary type.
	]]
	--[[
		*
		* Creates a type guard from any arbitrary type.
	]]
	--[[
		*
		* Hash a function using the method used internally by Flamework.
		* If a context is provided, then Flamework will create a new hash
		* if the specified string does not have one in that context.
		* @param str The string to hash
		* @param context A scope for the hash
	]]
	--[[
		*
		* Utility for use in test suites, not recommended for anything else.
	]]
	local Testing = {}
	do
		local _container_2 = Testing
		local function patchDependency(patchedClass, id)
			if id == nil then
				error("Patching failed, no ID")
			end
			local _3 = resolvedDependencies
			local _4 = id
			if _3[_4] ~= nil then
				error(id .. " has already been resolved, continuing is unsafe")
			end
			local _5 = idToTarget
			local _6 = id
			local idCtor = _5[_6]
			if idCtor == nil then
				error("Dependency " .. id .. " was not found and cannot be patched.")
			end
			local _7 = metadata
			local _8 = idCtor
			local classMetadata = _7[_8]
			if not classMetadata then
				error("Dependency " .. id .. " has no existing metadata.")
			end
			classMetadata.isPatched = true
			local _9 = metadata
			local _10 = idCtor
			-- ▼ Map.delete ▼
			_9[_10] = nil
			-- ▲ Map.delete ▲
			local _11 = metadata
			local _12 = patchedClass
			local _13 = classMetadata
			-- ▼ Map.set ▼
			_11[_12] = _13
			-- ▲ Map.set ▲
			local _14 = targetToId
			local _15 = patchedClass
			local _16 = id
			-- ▼ Map.set ▼
			_14[_15] = _16
			-- ▲ Map.set ▲
			local _17 = idToTarget
			local _18 = id
			local _19 = patchedClass
			-- ▼ Map.set ▼
			_17[_18] = _19
			-- ▲ Map.set ▲
		end
		_container_2.patchDependency = patchDependency
	end
	_container_1.Testing = Testing
end
-- eslint-disable-next-line @typescript-eslint/no-explicit-any
--[[
	*
	* Register a class as a Component.
]]
--[[
	*
	* Register a class as a Service.
	*
	* @server
]]
--[[
	*
	* Register a class as a Controller.
	*
	* @client
]]
--[[
	*
	* Marks this class as an external class.
	*
	* External classes are designed for packages and won't be
	* bootstrapped unless explicitly specified. Excluding this
	* inside of a package will make the class load as long as
	* it has been loaded.
]]
--[[
	*
	* Hook into the OnInit lifecycle event.
]]
--[[
	*
	* Hook into the OnStart lifecycle event.
]]
--[[
	*
	* Hook into the OnTick lifecycle event.
	* Equivalent to: RunService.Heartbeat
]]
--[[
	*
	* Hook into the OnPhysics lifecycle event.
	* Equivalent to: RunService.Stepped
]]
--[[
	*
	* Hook into the OnRender lifecycle event.
	* Equivalent to: RunService.RenderStepped
	*
	* @client
]]
return {
	Flamework = Flamework,
}
