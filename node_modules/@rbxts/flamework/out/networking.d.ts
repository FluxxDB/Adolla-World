/// <reference types="@rbxts/compiler-types" />
/// <reference types="@rbxts/types" />
/// <reference types="t" />
import { t } from "@rbxts/t";
export declare namespace Networking {
    interface Sink {
        /** @hidden */
        readonly _nominal_Networking_Sink: unique symbol;
    }
    export const Sink: Sink;
    export interface EventInfo {
        name: string;
    }
    export type Middleware<I extends ReadonlyArray<unknown> = unknown[], O = unknown> = (player?: Player, ...args: I) => O;
    export type MiddlewareFactory<I extends ReadonlyArray<unknown> = unknown[], O = unknown> = (next: (player?: Player, ...args: I) => O, event: EventInfo) => Middleware<I, O>;
    export type EventMiddleware<E> = {
        readonly [k in keyof E]?: E[k] extends (...args: infer I) => void ? [
            ...MiddlewareFactory<I, void>[]
        ] : never;
    };
    export type FunctionMiddleware<E> = {
        readonly [k in keyof E]?: E[k] extends (...args: infer I) => infer O ? [
            ...MiddlewareFactory<I, O | Sink>[]
        ] : never;
    };
    export type ServerHandler<M, R> = {
        /**
         * haha yo
         */
        connect<T extends keyof R, K extends R[T] extends (...args: infer P) => void ? P : never>(event: T, cb: (player: Player, ...args: K) => void, additionalGuards?: {
            [k in keyof K]?: t.check<K[k]>;
        }): RBXScriptConnection;
    } & M;
    export interface ServerMethod<T extends Array<unknown>> {
        (player: Player, ...args: T): void;
        fire(player: Player, ...args: T): void;
        /**
         * Sends this request to all connected clients.
         */
        broadcast(...args: T): void;
        /**
         * Sends this request to all connected clients, excluding specified players.
         * @param players The players to exclude
         */
        except(players: Player | Player[], ...args: T): void;
    }
    export type ClientHandler<M, R> = {
        connect<T extends keyof R, K extends R[T] extends (...args: infer P) => void ? P : never>(event: T, cb: (...args: K) => void, additionalGuards?: {
            [k in keyof K]?: t.check<K[k]>;
        }): RBXScriptConnection;
        predict<T extends keyof R>(event: T, ...args: R[T] extends (...args: infer P) => void ? P : never): RBXScriptConnection;
    } & M;
    export type ClientMethod<T extends Array<unknown>> = (...args: T) => void;
    export type ServerEventType<S, C> = ServerHandler<{
        [k in keyof S]: S[k] extends (...params: infer P) => void ? ServerMethod<P> : never;
    }, C>;
    export type ClientEventType<C, S> = ClientHandler<{
        [k in keyof C]: C[k] extends (...params: infer P) => void ? (...params: P) => void : never;
    }, S>;
    export type EventType<S, C> = {
        client: ClientEventType<S, C>;
        server: ServerEventType<C, S>;
    };
    type StaticGuards<T> = {
        [key in keyof T]: t.check<unknown>[];
    };
    export function createEvent<S, C>(_serverGuards: StaticGuards<S>, _clientGuards: StaticGuards<C>, serverMiddleware?: EventMiddleware<S>, clientMiddleware?: EventMiddleware<C>): EventType<S, C>;
    export {};
}
